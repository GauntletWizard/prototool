// Copyright (c) 2019 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package bazel

import (
	"fmt"
	"path/filepath"
	"sort"

	"github.com/uber/prototool/internal/protoc"
	"go.uber.org/zap"
)

type generator struct {
	logger *zap.Logger
}

func newGenerator(options ...GeneratorOption) *generator {
	generator := &generator{
		logger: zap.NewNop(),
	}
	for _, option := range options {
		option(generator)
	}
	return generator
}

func (g *generator) Generate(fileDescriptorSets protoc.FileDescriptorSets) ([]*Output, error) {
	filePathToOutput := make(map[string]*Output)
	for _, fileDescriptorSet := range fileDescriptorSets {
		outputs, err := g.generate(fileDescriptorSet)
		if err != nil {
			return nil, err
		}
		for _, output := range outputs {
			if _, ok := filePathToOutput[output.FilePath]; ok {
				return nil, fmt.Errorf("duplicate output file path: %s", output.FilePath)
			}
			filePathToOutput[output.FilePath] = output
		}
	}
	allOutputs := make([]*Output, 0, len(filePathToOutput))
	for _, output := range filePathToOutput {
		allOutputs = append(allOutputs, output)
	}
	sort.Slice(allOutputs, func(i int, j int) bool { return allOutputs[i].FilePath < allOutputs[j].FilePath })
	return allOutputs, nil
}

func (g *generator) generate(fileDescriptorSet *protoc.FileDescriptorSet) ([]*Output, error) {
	fileSet, err := newFileSet(fileDescriptorSet)
	if err != nil {
		return nil, err
	}
	return []*Output{
		{
			FilePath: filepath.Join(fileSet.AbsBaseDirPath, fileSet.RelDirPath, "BUILD.bazel"),
			Data:     generateBUILDBazelFile(newBazelFileSet(fileSet)),
		},
	}, nil
}

func generateBUILDBazelFile(bazelFileSet *bazelFileSet) []byte {
	p := newPrinter()
	p.P(`# @generated by prototool bazel generate. DO NOT EDIT.`)

	if bazelFileSet.ShouldGenerateRule("cc_proto_library") {
		//p.P()
		//p.P(`cc_library(`)
		//p.In()
		//p.P(`name = "`, bazelFileSet.CCLibraryName(), `",`)
		//p.PList("deps", bazelFileSet.CCLibraryDeps())
		//p.PList("visibility", bazelFileSet.CCLibraryVisibility())
		//p.Out()
		//p.P(`)`)

		p.P()
		p.P(`cc_proto_library(`)
		p.In()
		p.P(`name = "`, bazelFileSet.CCProtoLibraryName(), `",`)
		p.PList("deps", bazelFileSet.CCProtoLibraryDeps())
		p.PList("visibility", bazelFileSet.CCProtoLibraryVisibility())
		p.Out()
		p.P(`)`)
	}

	if bazelFileSet.ShouldGenerateRule("java_proto_library") {
		//p.P()
		//p.P(`java_library(`)
		//p.In()
		//p.P(`name = "`, bazelFileSet.JavaJavaLibraryName(), `",`)
		//p.PList("deps", bazelFileSet.JavaJavaLibraryDeps())
		//p.PList("visibility", bazelFileSet.JavaJavaLibraryVisibility())
		//p.Out()
		//p.P(`)`)

		p.P()
		p.P(`java_proto_library(`)
		p.In()
		p.P(`name = "`, bazelFileSet.JavaProtoLibraryName(), `",`)
		p.PList("deps", bazelFileSet.JavaProtoLibraryDeps())
		p.PList("visibility", bazelFileSet.JavaProtoLibraryVisibility())
		p.Out()
		p.P(`)`)
	}

	if bazelFileSet.ShouldGenerateRule("java_lite_proto_library") {
		//p.P()
		//p.P(`java_library(`)
		//p.In()
		//p.P(`name = "`, bazelFileSet.JavaLiteJavaLibraryName(), `",`)
		//p.PList("deps", bazelFileSet.JavaLiteJavaLibraryDeps())
		//p.PList("visibility", bazelFileSet.JavaLiteJavaLibraryVisibility())
		//p.Out()
		//p.P(`)`)

		p.P()
		p.P(`java_lite_proto_library(`)
		p.In()
		p.P(`name = "`, bazelFileSet.JavaLiteProtoLibraryName(), `",`)
		p.PList("deps", bazelFileSet.JavaLiteProtoLibraryDeps())
		p.PList("visibility", bazelFileSet.JavaLiteProtoLibraryVisibility())
		p.Out()
		p.P(`)`)
	}

	p.P()
	p.P(`proto_library(`)
	p.In()
	p.P(`name = "`, bazelFileSet.ProtoLibraryName(), `",`)
	p.PList("deps", bazelFileSet.ProtoLibraryDeps())
	p.PList("visibility", bazelFileSet.ProtoLibraryVisibility())
	p.Out()
	p.P(`)`)

	for _, file := range bazelFileSet.Files() {
		p.P()
		p.P(`proto_library(`)
		p.In()
		p.P(`name = "`, file.ProtoLibraryName(), `",`)
		p.PList("srcs", file.ProtoLibrarySrcs())
		p.PList("deps", file.ProtoLibraryDeps())
		p.PList("visibility", file.ProtoLibraryVisibility())
		p.Out()
		p.P(`)`)
	}

	return p.Bytes()
}
